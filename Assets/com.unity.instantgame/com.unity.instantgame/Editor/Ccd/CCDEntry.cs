#if IG_C106 || IG_C109 || IG_C201 || IG_C301 || IG_C302 // Auto generated by AddMacroForInstantGameFiles.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using UnityEditor;
using UnityEngine;

namespace Unity.AutoStreaming.CloudContentDelivery
{
    [Serializable]
    internal class EntryInfo
    {
        public string full_path;
        public string path;
        public long content_size;
        public string content_type;
        public string content_hash;
        public string objectKey;

        public EntryInfo(string fullPath, string path, string hash, long size, string contentType, string projectUuid)
        {
            this.full_path = fullPath;
            this.path = path;
            this.content_hash = hash;
            this.content_size = size;
            this.content_type = contentType;
            this.objectKey = projectUuid + "/" + hash;
        }
    }

    [Serializable]
    internal class EntryParams
    {
        public string path;
        public long content_size;
        public string content_type;
        public string content_hash;
        public string content_link;
        public EntryParams(EntryInfo info , string projectUuid)
        {
            this.path = info.path;
            this.content_hash = info.content_hash;
            this.content_size = info.content_size;
            this.content_type = info.content_type;
            this.content_link = string.Format("cos:{0}/{1}", projectUuid, info.content_hash);
        }
    }

    [Serializable]
    internal class Entry
    {
        public string path;
        public string entryid;
        public string content_type;
        public long content_size;
        public string content_hash;
        public string laset_modified;

        public static Entry[] LoadEntries(string cosKey, string bucketUuid)
        {
            if (string.IsNullOrEmpty(bucketUuid))
            {
                return null;
            }
            string url = string.Format("{0}api/v1/buckets/{1}/entries/?page={2}&per_page={3}", CCDInfo.ApiHost, bucketUuid, 1, 100000);

            try
            {
                using (HttpWebResponse resp = (HttpWebResponse)Util.GetHttpWebRequest4CCDThreaded(cosKey, url, "GET").GetResponse())
                {
                    if (resp.StatusCode.Equals(HttpStatusCode.OK))
                    {
                        string strJson;
                        using (Stream stream = resp.GetResponseStream())
                        {
                            using (StreamReader reader = new StreamReader(stream))
                            {
                                strJson = reader.ReadToEnd();
                            }
                        }
                        return JsonUtility.FromJson<EntriesRoot>("{\"Entries\":" + strJson + "}").Entries;
                    }
                    else
                    {
                        Debug.LogError(string.Format("Failed loading entries, bucketUuid: {0}", bucketUuid));
                    }
                }
            }
            catch (Exception e)
            {
                EditorUtility.DisplayDialog("Load Entries Error", e.Message, "OK");
            }
            return null;
        }

        public static bool SyncEntries(string projectGuid, string cosKey, string bucketUuid, List<System.Tuple<CCDResourceType, string>> toBeUploaded)
        {
            bool allSuccess = true;
            if (string.IsNullOrEmpty(bucketUuid))
                return allSuccess;

            var progressBarTitle = "AutoStreaming data uploading";

            EditorUtility.DisplayProgressBar(progressBarTitle, "Fetching remote entries ...", 0.1f);
            var remoteEntries = LoadEntries(cosKey, bucketUuid);

            var localEntries = GetLocalFileEntries(projectGuid, toBeUploaded);
            var toBeUpdated = new Dictionary<string, EntryInfo>();
            var toBeDeleted = new List<string>();

            int i = 0;
            float total = remoteEntries.Length;
            foreach (var entry in remoteEntries)
            {
                EditorUtility.DisplayProgressBar(progressBarTitle, "Syncing entries: " + (i++) + "/" + total, i / total);
                string entryPath = entry.path.StartsWith("/") ? entry.path.Substring(1) : entry.path;
                if (localEntries.ContainsKey(entryPath))
                {
                    EntryInfo info = localEntries[entryPath];
                    if (!entry.content_hash.Equals(info.content_hash))
                    {
                        toBeUpdated.Add(entry.entryid, info);
                    }
                    localEntries.Remove(entryPath);
                }
                else
                {
                    toBeDeleted.Add(entry.entryid);
                }
            }

            //delete entries
            i = 0;
            total = toBeDeleted.Count;
            foreach (var id in toBeDeleted)
            {
                EditorUtility.DisplayProgressBar(progressBarTitle, "Removing unused entries: " + (i++) + "/" + total, i / total);
                if (!DeleteEntry(cosKey, bucketUuid, id))
                {
                    Debug.LogError("Failed deleting CCD entry "+ id + ". Please try again after all upload finished.");
                    allSuccess = false;
                }
            }

            // update entries
            allSuccess = allSuccess && Util.UpdateFiles(cosKey, projectGuid, bucketUuid, toBeUpdated);

            //upload new entries
            allSuccess = allSuccess && Util.UploadFiles(cosKey, projectGuid, bucketUuid, localEntries);

            EditorUtility.ClearProgressBar();
            return allSuccess;
        }

        private static Dictionary<string, EntryInfo> GetLocalFileEntries(string projectGuid, List<System.Tuple<CCDResourceType, string>> toBeUploaded)
        {
            var entriesInfo = new Dictionary<string, EntryInfo>();
            foreach (var pair in toBeUploaded)
            {
                switch (pair.Item1)
                {
                    case CCDResourceType.StreamedResource:
                        GetStreamingFiles(projectGuid, entriesInfo, pair.Item2, new List<string> { ".abas" }, "AS/");
                        break;
                    case CCDResourceType.CustomCloudAssets:
                        GetStreamingFiles(projectGuid, entriesInfo, pair.Item2, null, "CUS/",true); // accept all extensions, recursive
                        break;
                    case CCDResourceType.AddressableAsset:
                        GetStreamingFiles(projectGuid, entriesInfo, pair.Item2, new List<string> { ".json", ".hash", ".bundle" });
                        break;
                    case CCDResourceType.InstantGame:
                        GetStreamingFiles(projectGuid, entriesInfo, pair.Item2, new List<string> { ".zip", ".png", ".unity_instantgame_meta" });
                        break;
                }
            }

            return entriesInfo;
        }

        private static void GetStreamingFiles(string projectGuid, Dictionary<string, EntryInfo> dict, string dir, List<string> extensions, string parent = null, bool recursive = false)
        {
            if (!Directory.Exists(dir))
                return;

            var root = new DirectoryInfo(dir);
            var files = root.GetFiles();
            foreach (var file in files)
            {
                // When @extension == null, we accept all extensions
                if (extensions != null && !extensions.Contains(file.Extension.ToLower()))
                    continue;

                var path = parent + file.Name;
                #if UNITY_WEBGL && (IG_C301 || IG_C302)
                path = parent + Util.AppendHash128ToFileNameIfNeeded(file.FullName);
                #endif
                //Debug.Log("File: "+ file.FullName + " Path: " + path);
                var entry = new EntryInfo(file.FullName, path, Util.GetFileMD5(file.FullName), file.Length,
                    "application/octet-stream", projectGuid);

                dict.Add(entry.path, entry);
            }

            if (!recursive)
                return;

            var subDirs = root.GetDirectories();
            foreach (var d in subDirs)
            {
#if UNITY_WEBGL
                if (parent == "CUS/" && (d.Name == "StreamingAssets" || d.Name == "Assets"))
                {
                    //do not add "CUS/"
                    GetStreamingFiles(projectGuid, dict, d.FullName, extensions, d.Name + "/", recursive);
                }
                else
#endif
                GetStreamingFiles(projectGuid, dict, d.FullName, extensions, parent + d.Name +"/", recursive);
            }
        }

        internal static bool CreateEntry(string cosKey, string projectUuid, string bucketUuid, EntryInfo info)
        {
            string url = string.Format("{0}api/v1/buckets/{1}/entries/", CCDInfo.ApiHost, bucketUuid);
            string requestBody = JsonUtility.ToJson(new EntryParams(info, projectUuid));
            try
            {
                using (HttpWebResponse resp = (HttpWebResponse)Util.GetHttpWebRequest4CCDThreaded(cosKey, url, "POST", requestBody).GetResponse())
                {
                    if (resp.StatusCode.Equals(HttpStatusCode.OK))
                    {
                        return true;
                    }
                    else
                    {
                        Debug.LogError(string.Format("Failed creating entry, bucketUuid: {0}, Entry: {1}", bucketUuid, info.full_path));
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError("Create Entries Error: " + info.path + e.Message);
            }
            return false;
        }

        internal static bool UpdateEntry(string cosKey, string projectUuid, string bucketUuid, string entryId, EntryInfo info)
        {
            string url = string.Format("{0}api/v1/buckets/{1}/entries/{2}/", CCDInfo.ApiHost, bucketUuid, entryId);
            string requestBody = JsonUtility.ToJson(new EntryParams(info, projectUuid));
            try
            {
                using (HttpWebResponse resp = (HttpWebResponse)Util.GetHttpWebRequest4CCDThreaded(cosKey, url, "PUT", requestBody).GetResponse())
                {
                    if (resp.StatusCode.Equals(HttpStatusCode.OK))
                    {
                        return true;
                    }
                    else
                    {
                        Debug.LogError(string.Format("Failed updating entry, bucketUuid: {0}, Entry id: {1} , Entry path: {2}}", bucketUuid, entryId, info.full_path));
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError("Update Entries Error: " + info.path + e.Message);
            }
            return false;
        }

        private static bool DeleteEntry(string cosKey, string bucketUuid, string entryId)
        {
            string url = string.Format("{0}api/v1/buckets/{1}/entries/{2}/", CCDInfo.ApiHost, bucketUuid, entryId);
            try
            {
                using (HttpWebResponse resp = (HttpWebResponse)Util.GetHttpWebRequest4CCDThreaded(cosKey, url, "DELETE").GetResponse())
                {
                    if (resp.StatusCode.Equals(HttpStatusCode.OK) || resp.StatusCode.Equals(HttpStatusCode.NoContent))
                    {
                        return true;
                    }
                    else
                    {
                        Debug.LogError(string.Format("Failed deleting entry, bucketUuid : {0}, Entry id: {1}, Code: {2}", bucketUuid, entryId, resp.StatusCode));
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(string.Format("Delete entry error: {0}", e.Message));
            }
            return false;
        }

        private static void CreateMultiEntries(string cosKey, string projectUuid, string bucketUuid, List<EntryInfo> createEntries)
        {
            if (createEntries.Count == 0)
                return;

            string url = string.Format("{0}api/v1/buckets/{1}/multientries/", CCDInfo.ApiHost, bucketUuid);
            string requestBody = "";

            foreach (var info in createEntries)
            {
                if (string.IsNullOrEmpty(requestBody))
                {
                    requestBody = "[\n";
                }
                else
                {
                    requestBody += ",";
                }
                requestBody += JsonUtility.ToJson(new EntryParams(info, projectUuid));
            }
            requestBody += "]\n";

            try
            {
                HttpWebRequest request = Util.GetHttpWebRequest4CCDThreaded(cosKey, url, "POST", requestBody);
                request.Timeout = createEntries.Count * 1000;
                using (HttpWebResponse resp = (HttpWebResponse)request.GetResponse())
                {
                    if (!resp.StatusCode.Equals(HttpStatusCode.OK))
                    {
                        Debug.LogError(string.Format("Failed creating multi entries, bucketUuid: {0}", bucketUuid));
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError("Create Entries Error: "  + e.Message);
            }
        }
    }

    [Serializable]
    internal class EntriesRoot
    {
        public Entry[] Entries;
    }
}

#endif  // IG_C106 || IG_C109 || IG_C201 || IG_C301 || IG_C302, Auto generated by AddMacroForInstantGameFiles.exe
