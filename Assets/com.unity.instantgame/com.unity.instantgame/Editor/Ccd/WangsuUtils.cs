#if IG_C106 || IG_C109 || IG_C201 || IG_C301 || IG_C302 // Auto generated by AddMacroForInstantGameFiles.exe

using COSXML.Utils;

using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using UnityEditor;
using UnityEngine;
using Wangsu.WcsLib.Core;
using Wangsu.WcsLib.HTTP;
using Wangsu.WcsLib.Utility;

namespace Unity.AutoStreaming.CloudContentDelivery
{
    public class WangsuUtils
    {
        [Serializable]
        class UploadInfo
        {
            public string uploadToken;
            public string uploadUrl;
        }
        [Serializable]
        class WangsuResponse
        {
            public string ctx;
        }

        internal class WangsuAuth
        {
            public string cosKey;
            public string bucketUuid;
            public string uploadToken;
            public long expiredTime;
        }

        internal class WangsuAuthHelper
        {
            internal static WangsuAuth tempAuth = null;
            internal static bool IsNearExpired(string cosKey, string bucketUuid)
            {
                if (tempAuth == null || tempAuth.cosKey != cosKey || tempAuth.bucketUuid != bucketUuid)
                    return true;

                return TimeUtils.GetCurrentTime(TimeUnit.SECONDS) >= tempAuth.expiredTime - 120;
            }

            internal static void RefreshAuth(string cosKey, string bucketUuid)
            {
                try
                {
                    string url = CCDInfo.ApiHost + "api/v1/buckets/" + bucketUuid + "/uploadtoken/";
                    using (HttpWebResponse resp = (HttpWebResponse)Util.GetHttpWebRequest4CCDThreaded(cosKey, url, "GET").GetResponse())
                    {
                        if (resp.StatusCode.Equals(HttpStatusCode.OK))
                        {
                            string strJson;
                            using (Stream stream = resp.GetResponseStream())
                            {
                                using (StreamReader reader = new StreamReader(stream))
                                {
                                    strJson = reader.ReadToEnd();
                                }
                            }
                            UploadInfo uploadInfo = JsonUtility.FromJson<UploadInfo>(strJson);

                            tempAuth = new WangsuAuth();
                            tempAuth.cosKey = cosKey;
                            tempAuth.bucketUuid = bucketUuid;
                            tempAuth.uploadToken = uploadInfo.uploadToken;
                            tempAuth.expiredTime = TimeUtils.GetCurrentTime(TimeUnit.SECONDS) + 3600; //expire in one hour
                        }
                    }
                }
                catch (Exception e)
                {
                    EditorUtility.DisplayDialog("Failed to refresh TemporaryAuth", e.Message, "OK");
                }
            }
        }

        internal static bool uploadMulti(string cosKey, string bucketUuid, EntryInfo entryInfo)
        {

            if (WangsuAuthHelper.IsNearExpired(cosKey, bucketUuid))
            {
                WangsuAuthHelper.RefreshAuth(cosKey, bucketUuid);
            }

            Mac mac = new Mac("", "");
            Auth auth = new Auth(mac);
            Config config = new Config(CCDInfo.WcsUploadHost, CCDInfo.WcsManageHost, true);

            byte[] data;
            long size = 0;

            using (FileStream fs = new FileStream(entryInfo.full_path, FileMode.Open, FileAccess.Read))
            {
                try
                {
                    size = fs.Length;
                    data = new byte[size];
                    fs.Read(data, 0, (int)size);
                }
                catch (Exception ex)
                {
                    throw ex;
                }
            }

            if (size == 0) 
            {
                Debug.LogWarning("WangsuUtils: Empty File Found: " + entryInfo.full_path);
                SimpleUpload simple = new SimpleUpload(auth, config);
                //here we use putPolicy as token
                HttpResult simRes = simple.UploadData(data, WangsuAuthHelper.tempAuth.uploadToken, entryInfo.objectKey);

                if ((int)HttpStatusCode.NotAcceptable == simRes.Code)
                {
                    Debug.Log("WangsuUtils: File Already Exist. Do not need to upload.");
                    return true;
                }

                if ((int)HttpStatusCode.OK != simRes.Code)
                {
                    Debug.LogError("WangsuUtils: SimpleUpload error");
                    return false;
                }
                return true;
            }

            long blockSize = 4 * 1024 * 1024;
            int firstChunkSize = 1024;

            if (firstChunkSize > size)
            {
                firstChunkSize = (int)size;
            }

            if (blockSize > size)
            {
                blockSize = (int)size;
            }

            SliceUpload su = new SliceUpload(auth, config);
            HttpResult result = su.MakeBlock(blockSize, 0, data, 0, firstChunkSize, WangsuAuthHelper.tempAuth.uploadToken, entryInfo.objectKey);

            if ((int)HttpStatusCode.NotAcceptable == result.Code)
            {
                Debug.Log("WangsuUtils: File Already Exist. Do not need to upload.");
                return true;
            }

            if ((int)HttpStatusCode.OK != result.Code)
            {
                Debug.LogError("WangsuUtils: Make block error");
                return false;
            }

            WangsuResponse wr = JsonUtility.FromJson<WangsuResponse>(result.Text);

            long blockCount = (size + blockSize - 1) / blockSize;
            string[] contexts = new string[blockCount];
            contexts[0] = wr.ctx;

            // 上传第 1 个 block 剩下的数据
            if (firstChunkSize < blockSize)
            {
                result = su.Bput(contexts[0], firstChunkSize, data, firstChunkSize, (int)(blockSize - firstChunkSize), WangsuAuthHelper.tempAuth.uploadToken, entryInfo.objectKey);

                if ((int)HttpStatusCode.OK != result.Code)
                {
                    Debug.LogError("WangsuUtils: Bput error");
                    return false;
                }

                wr = JsonUtility.FromJson<WangsuResponse>(result.Text);
                contexts[0] = wr.ctx;
            }

            // 上传后续 block，每次都是一整块上传
            for (int blockIndex = 1; blockIndex < blockCount; ++blockIndex)
            {
                long leftSize = size - blockSize * blockIndex;
                int chunkSize = (int)(leftSize > blockSize ? blockSize : leftSize);
                result = su.MakeBlock(chunkSize, blockIndex, data, (int)(blockSize * blockIndex), chunkSize, WangsuAuthHelper.tempAuth.uploadToken, entryInfo.objectKey);
                if ((int)HttpStatusCode.OK == result.Code)
                {
                    wr = JsonUtility.FromJson<WangsuResponse>(result.Text);
                    contexts[blockIndex] = wr.ctx;
                }
                else
                {
                    Debug.LogError("WangsuUtils: Makeblock error");
                    return false;
                }
            }

            // 合成文件，注意与前面打印的 ETag 对比
            // Debug.Log(entryInfo.objectKey);
            result = su.MakeFile(size, entryInfo.objectKey, contexts, WangsuAuthHelper.tempAuth.uploadToken);
            if ((int)HttpStatusCode.OK != result.Code)
            {
                Debug.LogError("WangsuUtils: MakeFile error");
                return false;
            }

            return true;
        }
    }
}

#endif  // IG_C106 || IG_C109 || IG_C201 || IG_C301 || IG_C302, Auto generated by AddMacroForInstantGameFiles.exe
